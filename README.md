# connection_pool
1.项目可以实现什么
为了提高MySQL数据库（基于C/S设计）的访问瓶颈，除了在服务器端增加缓存服务器缓存常用的数据
之外（例如redis），还可以增加连接池，来提高MySQL Server的访问效率，在高并发情况下，大量的
TCP三次握手、MySQL Server连接认证、MySQL Server关闭连接回收资源和TCP四次挥手 所耗费的
性能时间也是很明显的，增加连接池就是为了减少这一部分的性能损耗。

2.项目技术点有哪些
MySQL数据库编程、单例模式、queue队列容器、C++11多线程编程、线程互斥、线程同步通信和
unique_lock、基于CAS的原子整形、智能指针shared_ptr、lambda表达式、生产者-消费者线程模型

3.连接池功能点介绍
连接池科普
如果有人不太清楚数据库连接池的话可以简单科普一下：

连接池一般是在客户端而不是服务器端，在客户端复用已经创建的数据库连接，避免性能损耗。

有人可能疑惑：我就一个用户也就用一条连接也就够了吧？还用什么连接池

例子：QQ 客户端的并发场景

假设你在使用 QQ 时，虽然你是唯一的用户，但客户端会发起多个不同的操作：

线程 1：在后台更新聊天消息记录，向数据库读取历史消息。
线程 2：实时显示你在某个群中的聊天内容，同时写入数据库。
线程 3：正在处理你发送的一条语音消息，将其上传并存储到数据库中。
线程 4：后台任务正在从好友服务器同步最新的好友列表，并把数据写入数据库。
每个线程都可能需要独立的数据库连接来完成操作，所以连接池在这种场景下就会显得十分重要，它能有效管理多个并发连接，而不需要频繁创建和关闭连接。

具体功能点
连接池一般包含了数据库连接所用的ip地址、port端口号、用户名和密码以及其它的性能参数，例如初始连接量，最大连接量，最大空闲时间、连接超时时间等，该项目是基于C++语言实现的连接池，主要也是实现以上几个所有连接池都支持的通用基础功能。

初始连接量（initSize） ：表示连接池事先会和MySQL Server创建initSize个数的connection连接，当应用发起MySQL访问时，不用再创建和MySQL Server新的连接，直接从连接池中获取一个可用的连接就可以，使用完成后，并不去释放connection，而是把当前connection再归还到连接池当中。

最大连接量（maxSize） ：当并发访问MySQL Server的请求增多时，初始连接量已经不够使用了，此时会根据新的请求数量去创建更多的连接给应用去使用，但是创建的连接数量上限是maxSize，不能无限制的创建连接，因为每一个连接都会占用一个socket资源，一般连接池和服务器程序是部署在一台主机上的，如果连接池占用过多的socket资源，那么服务器就不能接收太多的客户端请求了。当这些连接使用完成后，再次归还到连接池当中来维护。

最大空闲时间（maxIdleTime） ：当访问MySQL的并发请求多了以后，连接池里面的连接数量会动态增加，上限是maxSize个，当这些连接用完再次归还到连接池当中。如果在指定的maxIdleTime里面，这些新增加的连接都没有被再次使用过，那新增加的这些连接资源就要被回收掉，只需要保持初始连接量initSize个连接就可以了。

连接超时时间（connectionTimeout） ：当MySQL的并发请求量过大，连接池中的连接数量已经到达maxSize了，而此时没有空闲的连接可供使用，那么此时应用从连接池获取连接无法成功，它通过阻塞的方式获取连接的时间如果超过connectionTimeout时间，那么获取连接失败，无法访问数据库。

该项目主要实现上述的连接池四大功能，其余连接池更多的扩展功能，可以自行实现。

4.MySQL Server参数介绍
mysql> show variables like ‘max_connections’;
该命令可以查看MySQL Server所支持的最大连接个数，超过max_connections数量的连接，MySQLServer会直接拒绝，所以在使用连接池增加连接数量的时候，MySQL Server的max_connections参数也要适当的进行调整，以适配连接池的连接上限。

5.功能实现设计
ConnectionPool.cpp和ConnectionPool.h：连接池代码实现
Connection.cpp和Connection.h：数据库操作代码、增删改查代码实现

连接池主要包含了以下功能点 ：
1.连接池只需要一个实例，所以ConnectionPool以单例模式进行设计
2.从ConnectionPool中可以获取和MySQL的连接Connection
3.空闲连接Connection全部维护在一个线程安全的Connection队列中，使用线程互斥锁保证队列的线程安全
4.如果Connection队列为空，还需要再获取连接，此时需要动态创建连接，上限数量是maxSize
5.队列中空闲连接时间超过maxIdleTime的就要被释放掉，只保留初始的initSize个连接就可以了，这个功能点肯定需要放在独立的线程中去做
6.如果Connection队列为空，而此时连接的数量已达上限maxSize，那么等待connectionTimeout时间，如果还获取不到空闲的连接，那么获取连接失败，此处从Connection队列获取空闲连接，可以使用带超时时间的mutex互斥锁来实现连接超时时间（并且在这段时间内是一直在监听有没有连接，有能用的就用了）
7.用户获取的连接用shared_ptr智能指针来管理，用lambda表达式定制连接释放的功能（不真正释放连接，而是把连接归还到连接池中）
8.连接的生产和连接的消费采用生产者-消费者线程模型来设计，使用了线程间的同步通信机制条件变量和互斥锁
![image](https://github.com/user-attachments/assets/c7bb062b-9b2b-4e80-9082-62938a62768a)
